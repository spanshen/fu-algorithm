# 剑指offer

## 07 重建二叉树——前序中序
前序的第一个数是root，创建root后，递归创建root的左右子树。
在中序序列里找到root，左边是左子树，右边是右子树。

```js
var buildTree = function (preorder, inorder) {
    if (preorder.length === 0 || inorder.length === 0) {
        return null;
    }
    let root = new TreeNode(preorder[0]);
    let index = findRoot(inorder, root.val);
    root.left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index));
    root.right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1));
    return root;
}

var findRoot = function (inorder, rootVal) {
    let index;
    for(let i = 0; i < inorder.length; i++) {
        if(inorder[i] === rootVal) {
            index = i;
            break;
        }
    }
    return index;
}
```



## 26 树的子结构
需要辅助函数check，用于判断A和B是不是一样的，从根结点开始判断。
check逻辑：如果A === null，不行，B不可能和他相同。B === null是ok的，有可能B到null结点了，单纯B是null也可。A和B的val不同，不行。如果过了这几关，那递归的check A和B的左右子树就可以了。
主函数，主要用来遍历A的结点，首先用root check一下。再递归遍历A，其实随便有一个子树和B相同就可以了。

```js
var isSubStructure = function(A, B) {
    if(!A || !B) {
        return false;
    }
    return check(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
};

var check = function(A, B) {
    if(!B) {
        return true;
    }
    if(!A) {
        return false;
    }
    if(A.val !== B.val) {
        return false;
    }
    return check(A.left, B.left) && check(A.right, B.right);
}
```



## 27 二叉树的镜像

需求是输出一颗树的镜像树。

递归，分别翻转左右子树。

遇到null结点，应该返回null。

```js
var mirrorTree = function(root) {
    if(root === null) {
        return null;
    }
    [root.left, root.right] = [root.right, root.left];
    mirrorTree(root.left);
    mirrorTree(root.right);
    return root;
};
```



## 28 对称的二叉树

判断一颗二叉树是不是对称的，和27题很像，但不一样。

其实是判断left.left === right.right left.right === right.left。

特殊情况处理：如果l和r都是null，那是对称的。如果有一个是null一个不是，那就不对称。

```js
var isSymmetric = function (root) {
    return check(root, root);
};

var check = function(l, r) {
    if(!l && !r) {
        return true;
    }
    if(!l || !r) {
        return false;
    }
    return l.val === r.val && check(l.left, r.right) && check(l.right, r.left);
}
```

